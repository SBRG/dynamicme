#============================================================
# File callback_gurobi.py
#
# Gurobi-specific callbacks
#
# Laurence Yang, SBRG, UCSD
#
# 23 Feb 2018:  first version
#============================================================

from six import iteritems
from builtins import range

from gurobipy import *
from cobra.solvers.gurobi_solver import status_dict

import numpy as np


def cb_benders(model, where):
    GAPTOL = model._gaptol
    precision_sub = model._precision_sub
    try:
        decomposer = model._decomposer
    except AttributeError:
        print('Need model._decomposer = decomposer')
        raise Exception('Need model._decomposer = decomposer')

    if where in (GRB.Callback.MIPSOL, GRB.Callback.MIPNODE):
        ### Lazy constraints only allowed for MIPNODE or MIPSOL
        ys = decomposer._ys
        z  = decomposer._z
        if where==GRB.Callback.MIPSOL:
            yopt = [model.cbGetSolution(y) for y in ys]
            zmaster = model.cbGetSolution(z)
            if np.nan in yopt:
                print('MIPSOL: nan in yopt!')
        elif where==GRB.Callback.MIPNODE:
            node_status = model.cbGet(GRB.Callback.MIPNODE_STATUS)
            if node_status==GRB.OPTIMAL:
                yopt = [model.cbGetNodeRel(y) for y in ys]
                zmaster = model.cbGetNodeRel(z)
            else:
                if model._verbosity>0:
                    print('non-optimal cbGet(MIPNODE_STATUS)=%g'%node_status)
                return

        decomposer.update_subobj(yopt)
        sub = decomposer.get_sub()
        sub.optimize(precision=precision_sub)

        if sub.Status == GRB.Status.UNBOUNDED:
            # Add feasibility cut, ensuring that cut indeed eliminates current incumbent
            if model._verbosity > 0:
                print('*'*40)
                print('Adding Feasibility cut')

            feascut = decomposer.make_feascut()
            model.cbLazy(feascut)
        else:
            zsub = decomposer.calc_sub_objval(yopt)
            #gap = zmaster - zsub
            gap = zsub - zmaster    # UB - LB
            relgap = gap/(1e-10+abs(zsub))

            if model._verbosity > 1:
                print('#'*40)
                print('zmaster=%g. zsub=%g. gap=%g' % (zmaster, zsub, gap))
                #print('#'*40)

            if relgap > GAPTOL:
                optcut = decomposer.make_optcut()
                model.cbLazy(optcut)

            else:
                # Accept as new incumbent
                pass


def cb_benders_multi(model, where):
    """
    --------------------------------------------------------
    Callback function for multicut Benders.

    ********************************************************
    From Gurobi documentation:
    "Your callback should be prepared to cut off solutions that violate any of your
    lazy constraints,
    >>> including those that have already been added.
    >>> Node solutions will usually respect previously added lazy constraints, but not always."
    ********************************************************

    --------------------------------------------------------
    Definitions

    Incumbent : best integer solution so far
    Fathomed node : node that won't be branched due to one of 3 reasons:
        (i) LP relaxation yields integer feasible solution
        (ii) LP relaxation became infeasible when branching (also integer infeasible)
        (iii) LP relaxation solution is worse than incumbent
    Nodes : a pair of MIPs generated by branching on a fractional variable xj<=a, xj>=b
    Root node : original MIP
    Leaf : unbranched node
    Best bound : minimum of all current leaf node objective values
    """
    try:
        master = model._master
    except AttributeError:
        print('Need model._master = master')
        raise Exception('Need model._master = master')

    #GAPTOL = master.gaptol
    #GAPABS = master.absgaptol
    GAPTOL = model.Params.MIPGap
    GAPABS = model.Params.MIPGapAbs
    precision_sub = master.precision_sub
    print_iter = master.print_iter  # print per print_iter iters
    verbosity = master.verbosity
    cut_strategy = master.cut_strategy
    nsol_keep = master.nsol_keep
    UB = 1e100
    LB = 1e-15
    y0 = master.y0
    yopt = None

    if verbosity > 2:
        print('*'*40)
        print('In callback with where: %s'%where)

    if where==GRB.Callback.MIP:
        if verbosity > 0:
            _iter = model.cbGet(GRB.Callback.MIP_ITRCNT)
            if np.mod(_iter,print_iter)==0:
                UB = master.UB
                LB = master.LB
                # Could also use MIP_OBJBND
                OBJBND = model.cbGet(GRB.Callback.MIP_OBJBND)
                gap = UB - LB
                relgap = gap / (1e-10 + abs(UB))
                nfeas = len(master.feascuts)
                nopt = len(master.optcuts)
                print(
                    'Iter=%d. Best UB=%g. Best LB=%g (MIP_OBJBND=%g). Gap=%g. Relgap=%g%%. nFeasCut=%d. nOptCut=%d'%(
                    _iter,UB,LB,OBJBND,gap,relgap*100,nfeas,nopt))

    elif where in (GRB.Callback.MIPSOL, GRB.Callback.MIPNODE):
    #elif where == GRB.Callback.MIPSOL:
        ### Lazy constraints only allowed for MIPNODE or MIPSOL
        #****************************************************
        # Only add Benders cut to exclude new incumbent?
        # Doesn't improve lower bound then, which is problematic.
        #****************************************************
        # In general, use lazy constraint to exclude incumebt (MIPSOL)
        # or to fathom node (MIPNODE) by rendering it infeasible with cut.
        # Note the solution in MIPNODE is the LP relaxation with potential
        # fractional values, and MIPSOL is the best integer solution.
        fy = master._fy
        ys = master._ys
        z  = master._z

        yprev = yopt

        if where==GRB.Callback.MIPSOL:
            yopt = np.array([model.cbGetSolution(y) for y in ys])
            zmaster = model.cbGetSolution(z)
            x_dict = {x:model.cbGetSolution(x) for x in model.getVars()}
            # Save solutions
            master.int_sols.append(yopt)
            # manage size
            if len(master.int_sols)>nsol_keep:
                master.int_sols.pop(0)

        elif where==GRB.Callback.MIPNODE:
            node_status = model.cbGet(GRB.Callback.MIPNODE_STATUS)
            if node_status==GRB.OPTIMAL:
                yopt = np.array([model.cbGetNodeRel(y) for y in ys])
                # potentially fractional relaxation
                zmaster = model.cbGetNodeRel(z)
                x_dict = {x:model.cbGetNodeRel(x) for x in model.getVars()}
            else:
                # Then node will get fathomed anyway since infeasible
                return

        sub_dict = master.sub_dict
        sub_objs = []
        opt_sub_inds = []
        master._iter += 1# Update global iter for maximal cut
        # Solve submodels, collect objs, and calculate UB
        for sub_ind, sub in iteritems(sub_dict):
            if cut_strategy=='maximal' and y0 is not None:
                iter_mp = master._iter
                sub.update_maximal_obj(yopt, y0, iter_mp, GAPABS)
            else:
                sub.update_obj(yopt)
            sub.model.optimize(precision=precision_sub)
            if verbosity>1:
                print('Submodel %s status = %s (%s)'%(
                    sub_ind, status_dict[sub.model.Status], sub.model.Status))

            if sub.model.Status == GRB.Status.UNBOUNDED:
                # Add feasibility cut, ensuring that cut indeed elimi current incumbent
                # If even one submodel infeasible, original problem infeasible.
                feascut = master.make_feascut(sub)
                master.feascuts.add(feascut)
                model.cbLazy(feascut)   # Add to lazy constraint pool 
            elif sub.model.Status == GRB.Status.INFEASIBLE:
                """
                Can happen if:
                a) using cut_strategy='mw' and fixobjval constraint is infeasible,
                b) if primal is unbounded ==> not likely since primal box constrained,
                c) solver mistakes unbounded for infeasible.
                """
                if verbosity>1:
                    print("Submodel %s is infeasible! Attempting fix."%sub_ind)
                if cut_strategy=='mw':
                    # Try to get a normal optimality cut instead.
                    # Alternatively, might have been nearly unbounded.
                    cons = sub.model.getConstrByName('fixobjval')
                    if verbosity>1:
                        print("fixobjval: %s %s %s"%(
                            sub.model.getRow(cons), cons.Sense, cons.RHS))
                    if cons is not None:
                        # Drastic:
                        sub.model.model.remove(cons)
                        sub.model.model.update()
                        sub.model.optimize(precision=precision_sub)
                        if verbosity>0:
                            if sub.model.Status==GRB.Status.INFEASIBLE:
                                print("****************************")
                                print("Could not make submodel %s feasible"%sub_ind)
                            else:
                                print("Submodel without mw constraint: %s (%s)"%(
                                    status_dict[sub.model.Status],sub.model.Status))
                        # cons.Sense = GRB.GREATER_EQUAL
                        # cons.RHS   = -GRB.INFINITY
                        # sub.model.update()
                        # sub.model.optimize(precision=precision_sub)
                else:
                    cut = sub.repair_infeas(master, yopt)
                    if cut is not None:
                        model.cbLazy(cut)   # Add to lazy constraint pool 

            if sub.model.Status == GRB.Status.OPTIMAL:
                sub_obj = sub._weight*sub.model.ObjVal
                sub_objs.append(sub_obj)
                opt_sub_inds.append(sub_ind)
                #********************************************
                if cut_strategy in ['mw','maximal']:
                    #****************************************
                    # Only update core point if incumbent (int feas) found
                    #****************************************
                    if where==GRB.Callback.MIPSOL:
                        if y0 is None:
                            if len(master.int_sols)==0:
                                pass
                            else:
                                yprev = master.int_sols.pop()
                                y0 = 0.5*(yopt+yprev)
                        else:
                            y0 = master.update_corepoint(yopt, y0)
                        master.y0 = y0
                    if y0 is not None:
                        if cut_strategy=='mw':
                            if abs(sub.model.ObjVal)<1e6:
                                master.solve_mw_cut(sub, y0)
                            else:
                                if verbosity>1:
                                    print("ObjVal(%g) too big for MW cut!"%sub.model.ObjVal)

        # "Node solutions will usually respect previously added lazy constraints, but not always."
        # Add back all feascut, including previous ones that may have been dropped
        n_viol = 0
        for cut in master.feascuts:
            if not constraint_satisfied(cut, x_dict, model.Params.FeasibilityTol):
                model.cbLazy(cut)
                n_viol+=1
        if verbosity>1:
            print("Number of previous feascuts violated: %g"%n_viol)

        #----------------------------------------------------
        # Get LB and UB for this node (subspace of full problem space)
        LB = zmaster
        # UB for this incumbent (MIPSOL) or fractional solution (MIPNODE)
        UB = sum(fy*yopt) + sum(sub_objs)

        # Update global bounds
        # Note: global LB is minimum of all leaf nodes
        if where==GRB.Callback.MIPSOL:
            # If incumbent, save as UB.
            # However, cuts may exclude it in next iteration.
            if UB<master.UB:
                master.UB = UB

            LB_best = model.cbGet(GRB.Callback.MIPSOL_OBJBND)
            master.LB = LB_best
        elif where==GRB.Callback.MIPNODE:
            LB_best = model.cbGet(GRB.Callback.MIPNODE_OBJBND)

        # Check gap for this node
        gap = UB - LB
        relgap = gap / (1e-10 + abs(UB))

        if relgap > GAPTOL:
            for sub_ind in opt_sub_inds:
                sub = sub_dict[sub_ind]
                optcut = master.make_optcut(sub)
                master.optcuts.add(optcut)
                # cut produces an extreme point even if y fractional.
                # If fractional, can it exclude incumbent?
                model.cbLazy(optcut)    # Add to lazy constraint pool

            # "Node solutions will usually respect previously added lazy constraints,
            # but not always."
            # Add back all the optcuts
            n_viol = 0
            for cut in master.optcuts:
                # Add previous constraints that were Violated
                if not constraint_satisfied(cut, x_dict, model.Params.FeasibilityTol):
                    # If so, add again to pool
                    model.cbLazy(cut)
                    n_viol+=1
            if verbosity>1:
                print("Number of previous optcuts violated: %g"%n_viol)
        else:
            # Accept as new incumbent (MIPSOL) or keep exploring node (MIPNODE)
            pass


def constraint_satisfied(constr, x_dict, feas_tol):
    """
    Constraint (constr) sastisfied for solution x?

    Output
    True (satisfied) or False (violated)
    """
    if hasattr(constr._lhs,'size'):
        lhs = sum([x_dict[constr._lhs.getVar(j)]*constr._lhs.getCoeff(j)
            for j in range(constr._lhs.size())]) +  constr._lhs.getConstant()
    else:
        lhs = constr._lhs

    if hasattr(constr._rhs,'size'):
        rhs = sum([x_dict[constr._rhs.getVar(j)]*constr._rhs.getCoeff(j)
            for j in range(constr._rhs.size())]) +  constr._rhs.getConstant()
    else:
        rhs = constr._rhs

    if constr._sense==GRB.LESS_EQUAL:
        return lhs <= rhs
    elif constr._sense==GRB.GREATER_EQUAL:
        return lhs >= rhs
    elif constr._sense==GRB.EQUAL:
        return abs(lbs-rhs)<feas_tol
    else:
        raise ValueError("unknown constraint sense: %s"%constr._sense)
